架构设计

链路追踪

Stream

Gateway LoadBalancer, round robin

JWT --  token   --  in Gateway service, will check the token, valid then call other related 

改造项目
    1. 分布式

        ex. scenario creation
                1. UI create init data, then call MD
                2. MD update data, as producer, send 


            ✅ 本地事务	        每个服务内部使用数据库事务（如 @Transactional）
            ✅ Kafka 事件驱动	服务间通过事件触发操作
            ✅ 补偿机制	        每个服务实现对应的回滚逻辑
            ✅ 幂等性	        所有操作必须幂等，避免重复执行造成副作用

                    consumer:
                        1. redis setnx  --  see if new
                        2. DB index
                        3. 业务唯一标识符   --  业务ID 判断


            分布式ID    snowflake-- 时钟回拨    --   butterfly-- 设置逻辑时间
            spring security -- TOKEN JWT
            微服务注册中心
            LoadBalancer
            链路追踪
                Zipkin
                    track ID   & parent ID


        分布式事务      跨多个服务，订单，库存，支付  多个数据库    --  但是同一个事务中完成
            ？？？ Rollover DS???       Kafka  消息一致
                                            唯一ID， UI details status、 MD details status/   abinitio status
                改造一下， UI -- MD -- Abinitio
                    UI  db
                    MD  db

                1. UI add init record
                2. UI call MD, MD init record
                3. all success, then call Ab
                4. Ab as a producer, once success, will put message in Kafka
                5. UI and MD as consumer(different consumer group), once get the message, then update the their own DB records as ready, MD mail to user MD data is ready
                6. UI and MD all updated success, then mail to user
                6. after time threadhod, will update the status as Failed, mail to user


            wechat app 
                user 余额   --   from user service / user db
                小商品      --   from goods service / goods db

                    订单服务发起下单请求

                        订单服务开启 Kafka 事务

                        订单服务调用用户服务扣款（本地事务）

                        订单服务调用商品服务扣库存（本地事务）

                        如果两步都成功，则发送 Kafka 消息（如“订单已创建”）并提交事务

                        如果任一步失败，则回滚 Kafka 事务，消息不会被发送

                        消费者（如库存服务、用户服务）只消费已提交的事务消息
            

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>   config mgmt
    EMAIL_TEMPLATE_CONFIG
        CLOB 字段
            1. springboot 设置 json size
            2. apply upload txt file to the back-end    --  mid-table, return mid-table-ID
            3. when all good, will remove the mid-table


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>   Redisson
    在分布式系统中 
        控制多个节点对共享资源的访问，              HY cache！！！
        确保在高并发环境下数据的一致性和操作的原子性

        可重入 
        watchdog    可续命

            UI / RWA / MD
                ↓
            尝试获取分布式锁（Redisson）
                ↓
            成功 → 修改 HY cache → 释放锁           RReadWriteLock
            失败 → 等待或重试

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>  OOM
    Mar report, large usage

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>  Questions in dev

        DB-Split 
            InheritableThreadLocal

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>   超卖

    1. Redisson + lock + 限制QPS

    2. 限制QPS + lua + MQ + sentinel 
        lua: 检查库存 + 扣减库存    --原子性
        MQ： 解耦， 异步处理 DB扣除内存
        sentinel： qps限制
        线程池： 限制最大线程数 也可以限流

    3. set + spop + MQ 
        SPOP 用于从集合（Set 类型）中随机移除并返回一个或多个元素。 --  SPOP key [count]        --直接原子性的扣除库存
        MQ： 解耦， 异步处理 DB扣除内存
        sentinel： qps限制
        线程池： 限制最大线程数 也可以限流


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>   QPS
【Redis QPS 限制方法总结】

一、QPS 概念
QPS（Queries Per Second）表示系统每秒处理的请求数量，是衡量系统性能的重要指标。

二、常见限流算法
1. 令牌桶算法：固定速率生成令牌，请求需获取令牌才能通过，适合平滑限流。
2. 漏桶算法：请求进入漏桶，按固定速率流出，超出速率的请求被丢弃。
3. 固定窗口计数：每个时间窗口内计数请求数，超过阈值则拒绝。
4. 滑动窗口计数：更精细地统计请求分布，适合高精度限流。

三、技术实现方式
1. Guava RateLimiter（Java）：
   - 使用令牌桶算法限制请求速率。
   - 示例：RateLimiter.create(100); // 每秒最多 100 次请求

2. Spring Boot 注解 + 拦截器：
   - 自定义注解 @QpsLimit 实现方法级别限流。

3. Nginx 限流配置：
   - 使用 limit_req_zone 和 limit_req 实现接口限流。
   - 示例：
     limit_req_zone $binary_remote_addr zone=req_limit:10m rate=5r/s;
     location /api/ {
         limit_req zone=req_limit burst=10 nodelay;
     }

4. Redis + Lua 脚本：
   - 利用 Redis 的原子性和 Lua 脚本实现滑动窗口限流，适用于分布式系统。

四、限流策略建议
- 配合监控系统（如 Prometheus + Grafana）实时观察 QPS。
- 设置降级处理机制，如返回缓存或提示稍后重试。
- 根据业务高峰期动态调整限流阈值。

【结束】


---------------------   项目难点

1. Kafka  幂等性。UI/MD/Abinitio        消息统一

2. Redis  热点key 过期