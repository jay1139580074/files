    ps -ef | grep java  命令找到对应进程的pid：1234
    top -H -p 1234     来找到cpu使用率比较高的一些线程

---------------------------    ClassLoader 类加载器        >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


    加载（Loading）	            读取 .class 文件，生成 Class 对象
    验证（Verification）	    检查字节码合法性、安全性
    准备（Preparation）	        分配静态变量内存，初始化默认值
    解析（Resolution）	        将符号引用转为直接引用（如方法、字段）
    初始化（Initialization）	执行类的 <clinit> 方法，初始化静态变量


双亲委派

类加载器	                加载内容	                                作用	                            由谁实现

Bootstrap ClassLoader	    Java 核心类库（如 java.lang.*）	          加载 JVM 启动所需的最基础类	        由 JVM 原生代码实现（不是 Java 类）
Extension ClassLoader	    jre/lib/ext 或 java.ext.dirs 中的类	      加载扩展类库，如加密、图形等	        由 Java 实现，继承自 ClassLoader
Application ClassLoader	    应用的类路径下的类（如 classpath）	       加载我们写的 Java 应用代码	         由 Java 实现，也是最常用的加载器
自定义 ClassLoader	        特定场景下的类（如插件、脚本）	            实现热加载、隔离加载等高级功能	       由开发者自己实现


---------------------------    JVM 结构        >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    线程共享
        元空间/方法区       类的信息，静态方法，运行时常量池，编译器编译的代码          --在内存中，不在JVM 中
        堆（Heap）          实例对象， 数组，字符串常量池

    线程不共享
        本地方法栈          native方法
        程序计数器          记录字节码运行地址
        栈 （stack）        每个线程有一个线程栈，对应线程中的每个方法有个栈帧

            栈帧
                操作数栈    草稿本，执行引擎根据程序计数器，执行局部变量表中的数据，取局部变量表--出栈， 执行结果放回局部变量表--入栈
                局部变量表  存放当前线程所有变量

                动态链接    存放方法全量名称，一个编号，到元空间/运行时常量池取下个方法的地址
                方法出口    
                异常表


JVM中对象在堆中的生命周期?
    在 JVM 内存模型的堆中，堆被划分为新生代和老年代 
    
    新生代又被进一步划分为 Eden区 和 Survivor区，Survivor 区由 From Survivor 和 To Survivor 组成
    
    当创建一个对象时，对象会被优先分配到新生代的 Eden 区 此时 JVM 会给对象定义一个对象年轻计数器（-XX:MaxTenuringThreshold）
    
    当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC） JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1
    
    对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会+1
    
    如果分配的对象超过了-XX:PetenureSizeThreshold，对象会直接被分配到老年代