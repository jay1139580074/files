    ps -ef | grep java  命令找到对应进程的pid：1234
    top -H -p 1234     来找到cpu使用率比较高的一些线程
    printf "%x\n" 12345  # 假设 12345 是高 CPU 的线程 TID

    jstack 1234 > jstack.log    
    grep 'nid=0x3039' jstack.log

            "Worker-Thread-1" #45 prio。。。
        java.lang.Thread.State: RUNNABLE                             ---  thread status
        at com.example.MyService.compute(MyService.java:42)          ---  method name
        ...


---------------------------    ClassLoader 类加载器        >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    加载（Loading）	            读取 .class 文件，生成 Class 对象
    验证（Verification）	    检查字节码合法性、安全性
    准备（Preparation）	        分配静态变量内存，初始化默认值
    解析（Resolution）	        将符号引用转为直接引用（如方法、字段）
    初始化（Initialization）	执行类的 <clinit> 方法，初始化静态变量


双亲委派    ：一个类加载器在加载类时，先把请求交给它的父加载器，只有父加载器无法完成加载时，才由自己加载。
    
    🎯 优点：
        避免类的重复加载
        保证核心类的安全性和一致性（比如你不能自定义一个 java.lang.String）

    类加载器	                加载内容	                                作用	                            由谁实现

    Bootstrap ClassLoader	    Java 核心类库（如 java.lang.*）	          加载 JVM 启动所需的最基础类	        由 JVM 原生代码实现（不是 Java 类）
    Extension ClassLoader	    jre/lib/ext 或 java.ext.dirs 中的类	      加载扩展类库，如加密、图形等	        由 Java 实现，继承自 ClassLoader
    Application ClassLoader	    应用的类路径下的类（如 classpath）	       加载我们写的 Java 应用代码	         由 Java 实现，也是最常用的加载器
    自定义 ClassLoader	        特定场景下的类（如插件、脚本）	            实现热加载、隔离加载等高级功能	       由开发者自己实现


---------------------------    JVM 结构        >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    线程共享
        ---------------------------    ---------------------------    ---------------------------    
        元空间/方法区       元数据：类的信息，静态方法，运行时常量池，编译器编译的代码          --在内存中，不在JVM 中
        ---------------------------    ---------------------------    ---------------------------    
        堆（Heap）          实例对象， 数组， 字符串常量池                             -- GC    OOM
        ---------------------------    ---------------------------    ---------------------------    
    线程不共享
        ---------------------------    ---------------------------    ---------------------------    
        本地方法栈          native方法
        ---------------------------    ---------------------------    ---------------------------    
        程序计数器          记录字节码运行地址
        ---------------------------    ---------------------------    ---------------------------    
        栈 （stack）        每个线程有一个线程栈，对应线程中的每个方法有个栈帧
        ---------------------------    ---------------------------    ---------------------------    
            栈帧        -- StackOverflowError   栈帧数量过多导致整个线程栈空间耗尽，    比如无限递归或极深的递归链

               ---------------------------    ---------------------------   ---------------------------    ---------------------------
                操作数栈    草稿本，执行引擎根据程序计数器，执行局部变量表中的数据，取局部变量表--出栈， 执行结果放回局部变量表--入栈       
               ---------------------------    ---------------------------   ---------------------------    ---------------------------
                局部变量表  存放当前线程所有变量                                                                                    
                ---------------------------    ---------------------------   ---------------------------    ---------------------------
                动态链接    存放方法全量名称，一个编号，到元空间/运行时常量池取下个方法的地址
                ---------------------------    ---------------------------   ---------------------------    ---------------------------
                方法出口    
                ---------------------------    ---------------------------   ---------------------------    ---------------------------
                异常表


JVM中对象在堆中的生命周期?

    在 JVM 内存模型的堆中，堆被划分为新生代和老年代 
    
        新生代又被进一步划分为 Eden区 和 Survivor区，Survivor 区由 From Survivor 和 To Survivor 组成
        ---------------------------    ---------------------------    ---------------------------    

        ---------------------------    ---------------------------    ---------------------------    

    🧠 新生代（Young Generation）结构
    新生代主要分为三个区域：

        Eden 区：新对象首次分配的地方

        Survivor 区：分为两个：S0 和 S1，用于对象在 GC 后的“搬迁”

        老年代（Old Generation）：存放生命周期长的对象
        ---------------------------    ---------------------------    ---------------------------    

    🔄 Minor GC 的触发与对象晋升流程
        ✅ 1. 对象创建
            新对象会被分配在 Eden 区
            如果 Eden 区空间不足，就会触发一次 Minor GC

        ✅ 2. Minor GC 过程
            GC 会清理 Eden 区中不再被引用的对象
            幸存的对象会被复制到一个 Survivor 区（比如 S0）
            每个对象都有一个 年龄计数器（Age），初始为 1

        ✅ 3. 多次 Minor GC 后的晋升
            每次 Minor GC，幸存对象会在 S0 和 S1 之间来回复制，年龄 +1
            一旦对象的年龄达到某个阈值（默认是 15），就会被晋升到 老年代        -XX:MaxTenuringThreshold=15
        ---------------------------    ---------------------------    ---------------------------    

        ---------------------------    ---------------------------    ---------------------------    
    
    
    🔍 Full GC 

            清理所有代（Young + Old）的不可达对象
            回收最大可能的内存空间
            触发时通常伴随着较高的停顿时间（Stop-The-World）

        触发原因	                                说明
        ---------------------------    ---------------------------    ---------------------------    
        老年代空间不足	                             Minor GC 后对象晋升失败，老年代无法容纳
        显式调用	                                调用了 System.gc()（建议避免）
        元空间不足	                                类加载过多，元空间爆满
        CMS GC 的失败回收	                        Concurrent Mark Sweep 回收失败，退化为 Full GC
        G1 GC 的 Mixed GC 达到阈值	                G1 在某些情况下也会触发 Full GC
        JNI 或 Direct Memory 分配失败	            本地内存不足时可能触发 Full GC 尝试回收堆内存


        ---------------------------    ---------------------------    ---------------------------    

        ---------------------------    ---------------------------    ---------------------------    
        🧠 JVM 中的主要 GC 类型
        ---------------------------    ---------------------------    ---------------------------    

            🔹 1. Minor GC（Young GC）
                回收新生代（Eden + Survivor 区）
                触发条件：Eden 区满了
                停顿时间短，频率高
        ---------------------------    ---------------------------    ---------------------------    

            🔹 2. Major GC（Old GC）
                回收老年代（Old Generation）
                有时与 Full GC 等价，但不一定回收元空间
                停顿时间长，频率低
        ---------------------------    ---------------------------    ---------------------------    

            🔹 3. Full GC
                回收整个堆（新生代 + 老年代）+ 元空间（Metaspace）

                触发条件：
                    老年代空间不足
                    元空间溢出
                    显式调用 System.gc()
                    CMS 回收失败
                    停顿时间最长，影响性能最大
        ---------------------------    ---------------------------    ---------------------------    

            🔹 4. Mixed GC（G1 专属）
                同时回收新生代和部分老年代的 Region
                G1 GC 的特色，兼顾吞吐量和停顿时间
                比 Full GC 更高效，停顿更可控
        ---------------------------    ---------------------------    ---------------------------    

        ---------------------------    ---------------------------    --------------------------- 

        🎯 调优建议：

            根据应用的内存使用情况设置合理的堆大小（-Xmx 不宜过小或过大）
            使用 G1 GC 可在大堆场景下获得更可控的停顿时间
            配合 GC 日志分析工具（如 GCViewer、GCEasy）进行回收效率评估
            避免频繁 Full GC，关注老年代晋升速率和元空间使用
        ---------------------------    ---------------------------    --------------------------- 

                参数	作用
        ---------------------------    ---------------------------    --------------------------- 
                -Xms	                                        初始堆大小
                -Xmx	                                        最大堆大小
                -Xmn	                                        新生代大小
                -XX:+UseG1GC	                                启用 G1 垃圾回收器
                -XX:MaxGCPauseMillis=200	                    G1 最大停顿时间目标
                -XX:MetaspaceSize / -XX:MaxMetaspaceSize	    元空间初始/最大大小
                -XX:+PrintGCDetails	                            打印 GC 日志
                -XX:+HeapDumpOnOutOfMemoryError	                OOM 时生成堆转储文件