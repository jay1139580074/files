>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
一、 事务与ACID
    ACID特性：
        理解数据库事务的原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）的定义和重要性。
    事务隔离级别：
        掌握MySQL提供的四种隔离级别（读未提交、读已提交、可重复读、序列化），并了解每种级别会引发的并发问题（脏读、不可重复读、幻读）
    隔离的实现：
        理解MVCC如何支持可重复读隔离级别，以及其他隔离级别的实现（如锁机制）
    ---------------------------    ---------------------------    ---------------------------    

二、 索引
    索引原理：:了解MySQL索引（特别是InnoDB的B+树索引）是如何工作的。
    索引类型：:知道聚簇索引（主键索引）和非聚簇索引的区别。
    索引优化：:掌握如何选择合适的索引、避免索引失效（如LIKE模糊查询、函数应用在索引列上），以及使用覆盖索引来提高查询效率。
    ---------------------------    ---------------------------    ---------------------------    

三、 存储引擎（重点关注InnoDB）
    页的结构：
        理解InnoDB存储引擎的页（Page）结构，包括文件头、索引目录、数据区、溢出页等。
    事务与锁：
        熟悉InnoDB的锁机制，如行锁、表锁、间隙锁（Gap Lock）等。
    Undo Log与Redo Log：
        理解它们在事务回滚和崩溃恢复中的作用。
    MVCC的实现：
        深入了解MVCC是如何通过Read View和undo log实现多版本并发控制的。
    ---------------------------    ---------------------------    ---------------------------    

四、 SQL优化与性能调优
    执行计划：:会看EXPLAIN的输出，理解其含义，判断SQL的执行效率。
    慢查询：:了解如何找出和分析慢查询日志。
    查询优化：:掌握一些常用的SQL优化技巧，如避免全表扫描、使用索引、合理使用join。
    ---------------------------    ---------------------------    ---------------------------    

五、 高可用与分布式
    主从复制：:了解MySQL的主从复制原理和应用场景。
    读写分离：:知道如何实现数据库的读写分离以提高系统并发能力。
    ---------------------------    ---------------------------    ---------------------------    

六、 安全
    SQL注入：:了解SQL注入攻击的原理以及如何防范，例如使用预编译的SQL语句或参数化查询。
---------------------------    存储引擎        >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


    存储引擎	    是否支持事务	是否支持外键	特点
    InnoDB	        ✅ 是	        ✅ 是	    默认引擎，支持事务、行级锁、高并发
    MyISAM	        ❌ 否	        ❌ 否	    读写性能高，支持全文索引，但不支持事务
    MEMORY	        ❌ 否	        ❌ 否	    数据存储在内存中，速度快但数据不持久
    CSV	            ❌ 否	        ❌ 否	    数据以 CSV 文件形式存储，适合导入导出
    ARCHIVE	        ❌ 否	        ❌ 否	    适合存储大量历史数据，只支持插入和查询
    BLACKHOLE	    ❌ 否	        ❌ 否	    所有写入的数据都会被“吞掉”，常用于日志复制
    NDB (Cluster)	✅ 是	        ❌ 否	    用于 MySQL Cluster，支持分布式存储



---------------------------    InnoDB 索引 -- B+树        >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    B+ 树是一种 多路平衡查找树，它的特点是：            更适合磁盘存储，因为它能减少磁盘 I/O 次数，提高查询效率。

        所有数据都存储在 叶子节点。
        非叶子节点只存储 索引值（键值），用于导航。
        所有叶子节点通过 链表连接，便于范围查询

    ---------------------------    ---------------------------    ---------------------------    

    InnoDB 支持两种 B+ 树索引：

    ---------------------------    ---------------------------    ---------------------------    

            MySQL 索引类型总结
        ==================
    ---------------------------    ---------------------------    ---------------------------    

        一、按逻辑功能分类
        ------------------
        1. 普通索引（INDEX）
        - 最基本的索引类型。
        - 用于加速查询，不强制唯一性。
        - 示例：CREATE INDEX idx_name ON users(name);

        2. 唯一索引（UNIQUE）
        - 索引列的值必须唯一，但允许 NULL。
        - 示例：CREATE UNIQUE INDEX idx_email ON users(email);

        3. 主键索引（PRIMARY KEY）
        - 每个表只能有一个主键索引。
        - 主键列值必须唯一且非空。
        - 示例：PRIMARY KEY (id)

        4. 全文索引（FULLTEXT）
        - 用于全文搜索，适用于 CHAR、VARCHAR、TEXT 类型。
        - 示例：CREATE FULLTEXT INDEX idx_content ON articles(content);

        5. 空间索引（SPATIAL）
        - 用于地理空间数据（如 POINT、POLYGON）。
        - 示例：CREATE SPATIAL INDEX idx_location ON maps(geom);
    ---------------------------    ---------------------------    ---------------------------    

        二、按物理存储分类

        1. 聚簇索引（Clustered Index）
            - 数据行与主键索引存储在一起。
            - InnoDB 的主键默认是聚簇索引。

        2. 非聚簇索引（Secondary Index）
            - 索引与数据分开存储。
            - 查询时需要“回表”获取完整数据。
    ---------------------------    ---------------------------    ---------------------------    

        三、按数据结构分类
        ------------------
        1. B+Tree 索引
            - 默认索引结构，支持范围查询、排序。
            - 适用于大多数场景。

        2. Hash 索引
            - 仅支持等值查询，不支持范围查询。
            - Memory 引擎显式支持，InnoDB 有自适应 Hash 索引。

        3. R-Tree 索引
            - 用于空间索引，支持地理位置数据。

        4. 倒排索引（用于全文索引）
            - 将词语映射到文档，实现高效文本搜索。
    ---------------------------    ---------------------------    ---------------------------    

        四、按字段个数分类
        ------------------
        1. 单列索引
        - 针对单个字段创建索引。

        2. 联合索引（复合索引）
        - 针对多个字段组合创建索引。
        - 注意“最左前缀原则”：查询必须包含最左边的字段才能使用索引。
    ---------------------------    ---------------------------    ---------------------------    

        五、其他说明
        ------------
        - 索引虽然能加速查询，但也会影响写入性能。
        - 应根据查询频率、字段选择性合理创建索引。
        - 使用 EXPLAIN 分析 SQL 是否使用了索引。



        类型	    名称	                         特点
        主键索引	聚簇索引（Clustered Index）	    数据行与主键一起存储在叶子节点
        非主键索引	辅助索引（Secondary Index）	    叶子节点存储的是主键的值，而不是整行数据

            explain SELECT * FROM `scores`;

            type:
                1. system / const       -- 查询常量或主键单行，最快
                2. eq_ref               -- 使用唯一索引查找单行
                3. ref                  -- 使用非唯一索引查找多行
                4. range                -- 范围扫描（BETWEEN、>、<）
                5. index                -- 全索引扫描（不读数据行）
                6. ALL                  -- 全表扫描（最慢）

            extra:
                1. Using index                  -- 使用覆盖索引，不访问数据行，最优
                2. Using where                  -- 使用 WHERE 条件过滤，正常
                3. Using index condition        -- 使用索引条件下推（ICP），优化型
                4. Using join buffer            -- 使用连接缓存，可能影响性能
                5. Using temporary              -- 使用临时表，性能下降
                6. Using filesort               -- 使用文件排序，最慢

    ---------------------------    ---------------------------    ---------------------------        

            (10, 'Alice', 25)
            (20, 'Bob', 30)
            (30, 'Carol', 22)
            (40, 'David', 28)
            (50, 'Eve', 35)
            (60, 'Frank', 26)
            (70, 'Grace', 31)
            (80, 'Helen', 29)
            (90, 'Ian', 33)
            (100, 'Jane', 27)


                                        [40]                         [80]
                                        /                             \
                        +------------------------+       +------------------------+
                        |        [20]            |       |        [60]            |
                        |                        |       |                        |
                    +--------------+   +--------------+   +--------------+   +--------------+
                    |10|Alice|25   |   |20|Bob|30     |   |30|Carol|22   |   |40|David|28   |
                    +--------------+   +--------------+   +--------------+   +--------------+

                    +--------------+   +--------------+   +--------------+   +--------------+
                    |50|Eve|35     |   |60|Frank|26   |   |70|Grace|31   |   |80|Helen|29   |
                    +--------------+   +--------------+   +--------------+   +--------------+

                    +--------------+   +--------------+
                    |90|Ian|33     |   |100|Jane|27   |
                    +--------------+   +--------------+

                叶子节点链表连接如下：
                [10] → [20] → [30] → [40] → [50] → [60] → [70] → [80] → [90] → [100]



---------------------------    MVCC--- Multi Version Concurency control   针对 并发读数据     >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    
    Read Committed（RC） ：每次查询都会生成新的 Read View
    Repeatable Read（RR）：整个事务期间使用同一个 Read View，保证多次读取一致

    隐藏字段：每行记录包含事务 ID（DB_TRX_ID）， 回滚指针（DB_ROLL_PTR）， ROW_NUM（如果没主键ID 则起作用
    ---------------------------    ---------------------------    ---------------------------        

    Undo Log：记录数据的历史版本，支持事务回滚和快照读取
        a. InnoDB 记录每行数据修改的记录
        b. 通过DB_ROLL_PRT 指向上一次修改的记录     类似一个修改记录 链

        c. 创建：发生事务修改数据
        d. 删除：事务结束，且没有其他事务读取undo log时 --  ReadView 不被读取时， Purge 线程回收
    ---------------------------    ---------------------------    ---------------------------        


    Read View：只读事务开始时创建的快照视图，决定当前事务能看到哪些数据版本
        a. 当前事务ID           --  trx_id        
        b. 当前未提交事务列表    --  m_ids  其中最小的： min_trx_id
        c. 未发生最大事务ID      -- 还未发生的事务 的ID  max_trx_id 
    ---------------------------    ---------------------------    ---------------------------        

A.1 每次只读事务创建，innoDB会创建一个事务ID， 同时会创建一个全局的readview
    2. 开始判断当前事务对行数据的可读性

    进入undo log，开始对比      当前记录的 DB_TRX_ID > max_trx_id, 不可能，max_trx_id 代表未发生的事务，标记 Read View 的时间边界，防止新事务干扰
        当前记录的 DB_TRX_ID < min_trx_id
            ✅ 是：说明该版本在当前事务开始前就已提交   -→ 可见
            ❌ 否：继续判断

        当前记录的 DB_TRX_ID in m_ids
            ✅ 是：说明该版本是未提交的事务            -→ 不可见
            ❌ 否：说明该版本已提交，但在当前事务之后   -→ 不可见

        如果不可见，就通过 DB_ROLL_PTR 找到上一版本的 Undo Log，继续比较其 DB_TRX_ID

        这个过程会沿着 Undo Log 链表不断回溯，直到找到一个符合可见性规则的版本为止。

---------------------------    行级锁   针对 写数据     >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    当你执行 UPDATE、DELETE 或 INSERT 时，InnoDB 会加行级锁：

        锁定的是 索引记录（不仅仅是数据行）。
        使用的是 Next-Key Lock（行锁 + 间隙锁）来防止幻读。
        写操作之间会互相阻塞，确保数据一致性。
    ---------------------------    ---------------------------    ---------------------------        

    触发：
        1️⃣ DML 语句中涉及“修改”操作时
            只要执行的是对数据有变更的语句，InnoDB 就会触发行级锁：
            UPDATE：锁住被更新的行
            DELETE：锁住被删除的行
            INSERT：可能锁住唯一索引冲突的行
            REPLACE：本质上是 DELETE + INSERT，也会加锁

        2️⃣ 显式加锁的查询语句
            SELECT ... FOR UPDATE
            SELECT ... LOCK IN SHARE MODE

---------------------------    间隙锁（Gap Lock）     >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    在查询范围内：          ----SQL 查询中定义的条件所覆盖的数据区间
        限制其他事务“插入”新的记录，
        修改操作交给行级锁限制
        

---------------------------    表锁     >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    ✅ 1. 使用 MyISAM 或 MEMORY 存储引擎
        这些引擎不支持行级锁，只能使用表锁。

    ✅ 2. 显式加锁
        你可以手动加表锁：
        LOCK TABLES users WRITE;
        -- 或
        LOCK TABLES users READ;
        加锁后，必须使用 UNLOCK TABLES 来释放。

    ✅ 3. DDL 操作（结构变更）
        如 ALTER TABLE、DROP TABLE、TRUNCATE 等操作，MySQL 会自动加表锁，防止并发修改。


1. LIKE '%xxx'：前置通配符无法使用索引  
2. OR：两边字段未同时命中索引则失效  
3. IS NULL / IS NOT NULL：可能不走索引  
4. NOT IN / NOT EXISTS：通常不使用索引  
5. <> / !=：不等于无法利用索引范围  
6. 函数包裹字段：如 YEAR(date)，会失效  
7. 类型转换：如 INT 与字符串比较  
8. ORDER BY RAND()：随机排序不走索引  
9. 联合索引未使用最左字段：违反最左前缀原则  
10. HAVING / DISTINCT：可能触发临时表或排序