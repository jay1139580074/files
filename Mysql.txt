>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
一、 事务与ACID
    ACID特性：
        理解数据库事务的原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）的定义和重要性。
    事务隔离级别：
        掌握MySQL提供的四种隔离级别（读未提交、读已提交、可重复读、序列化），并了解每种级别会引发的并发问题（脏读、不可重复读、幻读）。﻿
    隔离的实现：
        理解MVCC如何支持可重复读隔离级别，以及其他隔离级别的实现（如锁机制）
    ---------------------------    ---------------------------    ---------------------------    

二、 索引
    索引原理：:了解MySQL索引（特别是InnoDB的B+树索引）是如何工作的。
    索引类型：:知道聚簇索引（主键索引）和非聚簇索引的区别。
    索引优化：:掌握如何选择合适的索引、避免索引失效（如LIKE模糊查询、函数应用在索引列上），以及使用覆盖索引来提高查询效率。
    ---------------------------    ---------------------------    ---------------------------    

三、 存储引擎（重点关注InnoDB）
    页的结构：
        理解InnoDB存储引擎的页（Page）结构，包括文件头、索引目录、数据区、溢出页等。
    事务与锁：
        熟悉InnoDB的锁机制，如行锁、表锁、间隙锁（Gap Lock）等。
    Undo Log与Redo Log：
        理解它们在事务回滚和崩溃恢复中的作用。
    MVCC的实现：
        深入了解MVCC是如何通过Read View和undo log实现多版本并发控制的。
    ---------------------------    ---------------------------    ---------------------------    

四、 SQL优化与性能调优
    执行计划：:会看EXPLAIN的输出，理解其含义，判断SQL的执行效率。
    慢查询：:了解如何找出和分析慢查询日志。
    查询优化：:掌握一些常用的SQL优化技巧，如避免全表扫描、使用索引、合理使用join。
    ---------------------------    ---------------------------    ---------------------------    

五、 高可用与分布式
    主从复制：:了解MySQL的主从复制原理和应用场景。
    读写分离：:知道如何实现数据库的读写分离以提高系统并发能力。
    ---------------------------    ---------------------------    ---------------------------    

六、 安全
    SQL注入：:了解SQL注入攻击的原理以及如何防范，例如使用预编译的SQL语句或参数化查询。
---------------------------    存储引擎        >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


    存储引擎	    是否支持事务	是否支持外键	特点
    InnoDB	        ✅ 是	        ✅ 是	    默认引擎，支持事务、行级锁、高并发
    MyISAM	        ❌ 否	        ❌ 否	    读写性能高，支持全文索引，但不支持事务
    MEMORY	        ❌ 否	        ❌ 否	    数据存储在内存中，速度快但数据不持久
    CSV	            ❌ 否	        ❌ 否	    数据以 CSV 文件形式存储，适合导入导出
    ARCHIVE	        ❌ 否	        ❌ 否	    适合存储大量历史数据，只支持插入和查询
    BLACKHOLE	    ❌ 否	        ❌ 否	    所有写入的数据都会被“吞掉”，常用于日志复制
    NDB (Cluster)	✅ 是	        ❌ 否	    用于 MySQL Cluster，支持分布式存储



---------------------------    InnoDB 索引 -- B+树        >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    B+ 树是一种 多路平衡查找树，它的特点是：            更适合磁盘存储，因为它能减少磁盘 I/O 次数，提高查询效率。

        所有数据都存储在 叶子节点。
        非叶子节点只存储 索引值（键值），用于导航。
        所有叶子节点通过 链表连接，便于范围查询

    ---------------------------    ---------------------------    ---------------------------    

    InnoDB 支持两种 B+ 树索引：

        类型	    名称	                         特点
        主键索引	聚簇索引（Clustered Index）	    数据行与主键一起存储在叶子节点
        非主键索引	辅助索引（Secondary Index）	    叶子节点存储的是主键的值，而不是整行数据

    ---------------------------    ---------------------------    ---------------------------        

            (10, 'Alice', 25)
            (20, 'Bob', 30)
            (30, 'Carol', 22)
            (40, 'David', 28)
            (50, 'Eve', 35)
            (60, 'Frank', 26)
            (70, 'Grace', 31)
            (80, 'Helen', 29)
            (90, 'Ian', 33)
            (100, 'Jane', 27)


                                        [40]                         [80]
                                        /                             \
                        +------------------------+       +------------------------+
                        |        [20]            |       |        [60]            |
                        |                        |       |                        |
                    +--------------+   +--------------+   +--------------+   +--------------+
                    |10|Alice|25   |   |20|Bob|30     |   |30|Carol|22   |   |40|David|28   |
                    +--------------+   +--------------+   +--------------+   +--------------+

                    +--------------+   +--------------+   +--------------+   +--------------+
                    |50|Eve|35     |   |60|Frank|26   |   |70|Grace|31   |   |80|Helen|29   |
                    +--------------+   +--------------+   +--------------+   +--------------+

                    +--------------+   +--------------+
                    |90|Ian|33     |   |100|Jane|27   |
                    +--------------+   +--------------+

                叶子节点链表连接如下：
                [10] → [20] → [30] → [40] → [50] → [60] → [70] → [80] → [90] → [100]



---------------------------    MVCC--- Multi Version Concurency control   针对 并发读数据     >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    
    Read Committed（RC） ：每次查询都会生成新的 Read View
    Repeatable Read（RR）：整个事务期间使用同一个 Read View，保证多次读取一致

    隐藏字段：每行记录包含事务 ID（DB_TRX_ID）， 回滚指针（DB_ROLL_PTR）， ROW_NUM（如果没主键ID 则起作用
    ---------------------------    ---------------------------    ---------------------------        

    Undo Log：记录数据的历史版本，支持事务回滚和快照读取
        a. InnoDB 记录每行数据修改的记录
        b. 通过DB_ROLL_PRT 指向上一次修改的记录     类似一个修改记录 链

        c. 创建：发生事务修改数据
        d. 删除：事务结束，且没有其他事务读取undo log时 --  ReadView 不被读取时， Purge 线程回收
    ---------------------------    ---------------------------    ---------------------------        


    Read View：只读事务开始时创建的快照视图，决定当前事务能看到哪些数据版本
        a. 当前事务ID           --  trx_id        
        b. 当前未提交事务列表    --  m_ids  其中最小的： min_trx_id
        c. 未发生最大事务ID      -- 还未发生的事务 的ID  max_trx_id 
    ---------------------------    ---------------------------    ---------------------------        

A.1 每次只读事务创建，innoDB会创建一个事务ID， 同时会创建一个全局的readview
    2. 开始判断当前事务对行数据的可读性

    进入undo log，开始对比      当前记录的 DB_TRX_ID > max_trx_id, 不可能，max_trx_id 代表未发生的事务，标记 Read View 的时间边界，防止新事务干扰
        当前记录的 DB_TRX_ID < min_trx_id
            ✅ 是：说明该版本在当前事务开始前就已提交   -→ 可见
            ❌ 否：继续判断

        当前记录的 DB_TRX_ID in m_ids
            ✅ 是：说明该版本是未提交的事务            -→ 不可见
            ❌ 否：说明该版本已提交，但在当前事务之后   -→ 不可见

        如果不可见，就通过 DB_ROLL_PTR 找到上一版本的 Undo Log，继续比较其 DB_TRX_ID

        这个过程会沿着 Undo Log 链表不断回溯，直到找到一个符合可见性规则的版本为止。

---------------------------    行级锁   针对 写数据     >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    当你执行 UPDATE、DELETE 或 INSERT 时，InnoDB 会加行级锁：

        锁定的是 索引记录（不仅仅是数据行）。
        使用的是 Next-Key Lock（行锁 + 间隙锁）来防止幻读。
        写操作之间会互相阻塞，确保数据一致性。
    ---------------------------    ---------------------------    ---------------------------        

    触发：
        1️⃣ DML 语句中涉及“修改”操作时
            只要执行的是对数据有变更的语句，InnoDB 就会触发行级锁：
            UPDATE：锁住被更新的行
            DELETE：锁住被删除的行
            INSERT：可能锁住唯一索引冲突的行
            REPLACE：本质上是 DELETE + INSERT，也会加锁

        2️⃣ 显式加锁的查询语句
            SELECT ... FOR UPDATE
            SELECT ... LOCK IN SHARE MODE

---------------------------    间隙锁（Gap Lock）     >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    在查询范围内：          ----SQL 查询中定义的条件所覆盖的数据区间
        限制其他事务“插入”新的记录，
        修改操作交给行级锁限制
        

---------------------------    表锁     >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    ✅ 1. 使用 MyISAM 或 MEMORY 存储引擎
        这些引擎不支持行级锁，只能使用表锁。

    ✅ 2. 显式加锁
        你可以手动加表锁：
        LOCK TABLES users WRITE;
        -- 或
        LOCK TABLES users READ;
        加锁后，必须使用 UNLOCK TABLES 来释放。

    ✅ 3. DDL 操作（结构变更）
        如 ALTER TABLE、DROP TABLE、TRUNCATE 等操作，MySQL 会自动加表锁，防止并发修改。