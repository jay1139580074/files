Deamon thread   --  JVM will close in only exsting daemon threads

FutureTask.get()
    if thread done, will return
    BUT if not completed, then will blocking current main thread

FutureTask.isdone()
    will check the status 轮询, waste CPU

CompletableFuture
    if not custom a threadPool, it will set a ForkJoinPool by auto  --  旁路线程


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

---------------------------    类锁/对象锁        >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        初始为 无锁。
        第一个线程访问时，进入 偏向锁。
        如果有其他线程竞争，撤销偏向锁，升级为 轻量级锁。
        如果 CAS 失败或竞争激烈，升级为 重量级锁。

        JVM 会根据运行时的实际情况自动调整锁状态，以达到最优性能。


    悲观锁：Synchronized    &   Lock

    任何Object 都可以成为一个锁
        --  ObjectMonitor.class 每个Object自带一个对象监视器

    Synchronized 如何获取到锁

        ObjectMonitor 对象，
            字节码  monitorenter    --加锁    monitorexit   --解锁

        1. 对同一个对象，所有synchronozed 修饰的方法，只有一个线程，需要顺序执行   
            --  one Synchronized method completed, then start another Synchronized method
            --  normal method will not effecet, get its own thread

        2. static Synchronized     --      对象锁，锁的是整个对象calss
            --  one Synchronized method completed, then start another Synchronized method

        3. static {...}            --      代码块锁，锁的是static(obj) 中的obj对象

        对象锁 类锁 不一样，不会使用同一个线程，不会冲突
    
    >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    ---------------------------    ReentrantLock   公平锁/非公平锁        >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

        Reentrant means a thread can acquire the same lock multiple times without causing a deadlock.
            
            new ReentrantLock(true) 
                    --  Fair lock: Threads acquire the lock in the order they requested it.
                    --  线程切换有开销
            
            new ReentrantLock()     
                    --   Non-fair lock: Threads can "jump the queue" for better performance.
                    --   效率更高，开销更小

    ---------------------------    可重入锁/递归锁       >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

        Synchronized & ReentrantLock  都是可重入锁

        ReentrantLock   需要每次手动lock unlock

        一个线程，中有多个流程，这些流程可以自动获取当前对象自己的锁

    ---------------------------    死锁       >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

        how to check :
            1. commands:
                jps -l
                jstack  进程号
            2. 图形化工具  jconsol


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

---------------------------    中断机制        >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    one thread should stop by thread itself
>>>>>>>>>
    how to stop a thread
        1. 通过一个volatile变量实现
        2. 通过AtomicBoolean
        3. 通过Thread类自带的中断API实例方法实现 
        
>>>>>>>>>
    public void interrupt()	
        set interrupted = true

        如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而己。 
            被设置中断标志的线程将继续正常运行，不受影响。 
            所以， interrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行。

        如果线程处于被阻塞状态(例如处于sleep, wait, join 等状态)，
            在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态，
            并抛出一个InterruptedException异常。

            !!!--- so in catch InterruptedException, need to interrupt() again!!!!!

    public static boolean interrupted()	
        1. return interrupted
        2. set interrupted = false

    public boolean isInterrupted()	
        return interrupted


---------------------------    等待唤醒        >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    1. 使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程           先wait()， 再notify()
    2. 使用JUC包中Condition的await()方法让线程等待，使用signal()方法唤醒线程            先await(), 再signl()
    3. LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程                            无顺序要求

---------------------------    LockSupport        >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

        创建一个Lock    以及        基本线程阻塞原语

    1. 正常+无锁块要求
    2. 之前错误的先唤醒后等待，LockSupport照样支持      unpark(thread) 以后，permit会一直存在，无论什么时候再去park
    3. 先两次 LockSupport.park, 再不管多少次LockSupport.unPark(thread)，都会阻塞        ----------------    LockSupport和每个使用它的线程都有一个许可(permit)关联。

    每个线程都有一个相关的permit，permit最多只有一个，重复调用unpark也不会积累凭证。

    >>>>>>>>>>>>>>  为什么可以突破wait/notify的原有调用顺序？

        因为unpark获得了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞。先发放了凭证后续可以畅通无阻。

    >>>>>>>>>>>>>>  为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程？

        因为凭证的数量最多为1，连续调用两次unpark和调用一次unpark效果一样，只会增加一个凭证；而调用两次park却需要消费两个凭证，证不够，不能放行。


---------------------------    JMM-Java Memory Model        >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
本质是一种协议，规定了 线程和主内存的交互协议
    
    1. 各个线程对数据的操作    --      各个线程的工作内存      --          最终才会写到主内存
    2. 各个工作内存相互不能访问
    3. 所有共享变量都在主内存中


---------------------------    CAS        >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    getAndAdd       voletile 确保可见性
                    自旋 compareAndSawp  确保更新

    UNSAFE class    weakCompareAndSetInt（object, offset, expect, newVal）
    Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据

    ABA 问题
        AtomicStampedReference
        AtomicMarkableReference

    循环长，开销大


---------------------------    ThreadLocal        >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    ● ThreadLocal并不解决线程间共享数据的问题
    ● ThreadLocal适用于变量在线程间隔离且在方法间共享的场景
    ● ThreadLocal通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题
    ● 每个线程持有一个只属于它自己的专属map并维护了ThreadLocal对象与具体实例的映射，该Map由于只被持有他的线程访问，故不存在线程安全以及锁的问题
    ● ThreadLocalMap的Entry对ThreadLocal的引用为弱引用。避免了ThreadLocal对象无法被回收的问题


    内存泄漏：
        key 是弱引用：ThreadLocalMap 中的 key 是 ThreadLocal 的弱引用 (WeakReference<ThreadLocal<?>>)。
             这意味着，如果 ThreadLocal 实例不再被任何强引用指向，垃圾回收器会在下次 GC 时回收该实例，导致 ThreadLocalMap 中对应的 key 变为 null。

             why:       static class Entry extends WeakReference<ThreadLocal<?>> {
                            Object value;
                        }
            
        value 是强引用：即使 key 被 GC 回收，value 仍然被 ThreadLocalMap.Entry 强引用存在，无法被 GC 回收。 

            why: value set manually

 

        需要手动.remove()


    ● 都会通过expungeStaleEntry，cleanSomeSlots，replaceStaleEntry这三个方法回收键为null的Entry对象的值（即为具体实例）以及entry对象本身从而防止内存泄漏，属于安全加固的方法

---------------------------    AQS        >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    尝试获取资源：tryAcquire(arg)
        子类实现该方法，尝试获取锁。
        如果成功，线程直接进入临界区。
        如果失败，进入等待队列。

    入队：addWaiter(Node.EXCLUSIVE)
        将当前线程封装成一个 Node，加入到 CLH 队列尾部。
        使用 CAS 保证入队的原子性。

    自旋等待：acquireQueued(node, arg)
        当前线程在队列中自旋等待。
        如果前驱节点是头节点且资源可用，则尝试获取。
        否则调用 LockSupport.park() 挂起线程

    唤醒机制
        当持有锁的线程释放资源时，会唤醒队列中的下一个等待线程
        唤醒后线程重新尝试获取资源


AQS 是 Java 并发包中用于构建锁和同步器的基础框架。
    它通过一个 volatile int state 变量表示同步状态，    --CAS 保证原子性
        并使用一个 FIFO 的 CLH 队列管理线程的排队等待。
    每个线程在获取资源失败时，会被封装成一个 Node 加入队列，进入阻塞状态，直到被唤醒。

子类通过实现 tryAcquire 和 tryRelease 等模板方法，定义具体的同步逻辑。

AQS 支持独占和共享两种模式，适用于不同类型的同步器，如 ReentrantLock、Semaphore、CountDownLatch 等。

        独占模式	同一时刻只有一个线程持有资源	ReentrantLock
        共享模式	多个线程可以同时访问资源	    Semaphore, CountDownLatch, ReadWriteLock

此外，AQS 还提供了 ConditionObject，用于实现更灵活的等待/通知机制。整体设计遵循模板方法模式，结构清晰，扩展性强。


---------------------------    Thread Pool        >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

        ThreadPoolExecutor(
            int corePoolSize,               // 核心线程数
            int maximumPoolSize,            // 最大线程数
            long keepAliveTime,              // 非核心线程空闲存活时间
            TimeUnit unit,                   // 时间单位
            BlockingQueue<Runnable> workQueue, // 任务队列
            ThreadFactory threadFactory,     // 线程工厂
            RejectedExecutionHandler handler // 拒绝策略
        )

提交任务 → 核心线程是否空闲？
    ├─ 是 → 直接用核心线程执行
    └─ 否 → 放入任务队列
             ├─ 队列满？ 
             │    ├─ 否 → 等待执行
             │    └─ 是 → 创建非核心线程（直到最大线程数）
             │              └─ 仍无法执行 → 启动拒绝策略
